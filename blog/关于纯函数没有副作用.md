# 关于纯函数没有副作用
- >作者：evinyang
- >时间：2025年11月14日
---
# 问题：函数式编程的纯函数如何保证不产生副作用？
- 函数式编程的核心 —— 纯函数

- “无副作用”的特性
>“无副作用”的特性（输出仅由输入决定，不影响外部环境）并非天然存在，而是通过`明确的设计原则和约束`来保证的。
---
# 纯函数避免副作用的核心机制和实践方法
## 一、明确“副作用”的定义
- 副作用是指**函数对外部环境的任何改变，或依赖外部环境的状态**

- 副作用常见形式包括：
```
- 修改全局变量、静态变量、参数对象（引用类型）； 
- 执行IO操作（读写文件、网络请求、打印输出）；
- 调用其他有副作用的函数（如数据库写入）； 
- 依赖随机数、当前时间等动态外部状态。
```
- `纯函数`的目标
>完全消除副作用行为，使函数成为`“输入→输出”的纯映射`。
## 二、纯函数的设计原则：消除外部依赖与影响
### 1. 输出仅由输入决定（确定性）
>函数的返回值必须唯一依赖于传入的参数，不依赖任何外部状态（如全局变量、系统时间）。 

- 反例：依赖全局配置的函数 
```py
config = {
     "tax_rate": 0.1}
def calculate_tax(price):
    return price * config["tax_rate"]  # 依赖外部config，非纯函数

```
- 正例：通过参数传入依赖 
```py
def calculate_tax(price, tax_rate):
    return price * tax_rate  # 输出仅由输入决定，纯函数
```
### 2. 不修改输入参数（尤其是引用类型）
>在处理列表、字典等引用类型时，纯函数不能修改原对象，而应返回新对象。

- 反例：修改输入列表 
```py
def add_item(lst, item):
    lst.append(item)  # 修改原列表，产生副作用
    return lst
```
- 正例：返回新列表
```py
def add_item(lst, item):
    return [*lst, item]  # 创建新列表，不影响原对象
```
### 3. 禁止读写外部状态
>纯函数不能修改全局变量、静态变量，也不能执行IO操作（如打印、文件读写）。 

- 反例：包含打印操作
```py
def sum(a, b):
    result = a + b
    print(f"Sum: {result}")  # 打印是副作用（输出到控制台）
    return result
```
- 正例：剥离副作用 
```py
def sum(a, b):
    return a + b  # 纯函数，仅计算

# 副作用单独处理
def print_sum(a, b):
    print(f"Sum: {sum(a, b)}")

```
## 三、语言层面的辅助机制
>部分函数式语言（如`Haskell`、`Scala`）提供语法或类型`系统约束`，帮助开发者编写纯函数： 
- 不可变数据类型
```
- 默认数据结构不可修改（如Scala的List、Python的tuple）
- 修改操作会返回新对象，避免意外副作用
```
- 类型标记
```
- Haskell通过IO类型明确标记有副作用的函数（如readFile :: FilePath -> IO String）
- 纯函数（如(+) :: Int -> Int -> Int）
- 副作用的函数与纯函数严格区分，编译时即可识别副作用
```
- 禁止全局变量
>部分语言限制全局变量的使用，强制通过参数传递数据，减少外部依赖
## 四、实践中的“副作用隔离”
>实际开发中`完全无副作用`的代码几乎不存在（如必须读写数据库），函数式编程通过“`分离纯逻辑与副作用`” 保证核心逻辑的纯度： 

- 将核心业务逻辑（如数据计算、规则验证）封装为纯函数

- 将副作用操作（如IO、数据库交互）抽离为单独的“副作用函数”

- 通过“管道”或“`monad`”连接纯函数与副作用函数，确保副作用被控制在特定边界
```
- Haskell的IO monad
- Python的functools
```
>例如处理用户数据：
```py
# 纯函数：验证用户年龄（无副作用）
def is_adult(age):
    return age >= 18

# 副作用函数：读取数据库（有IO）
def fetch_user_age(user_id):
    # 数据库查询（副作用）
    return db.query("SELECT age FROM users WHERE id = ?", user_id)

# 组合：纯逻辑 + 副作用（副作用被隔离）
def check_user_adult(user_id):
    age = fetch_user_age(user_id)  # 显式调用副作用
    return is_adult(age)

```
---
# 总结
>纯函数的“无副作用”并非天生，而是通过`设计约束`（输入决定输出、不修改外部状态）、`语言特性`（不可变数据、类型约束）和`实践模式`（分离纯逻辑与副作用）实现的。
>这种特性使函数更`易测试`、`复用`和`并行执行`，也是`函数式编程可靠性的核心来源`。