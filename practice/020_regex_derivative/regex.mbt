// see [https://www.khoury.northeastern.edu/home/turon/re-deriv.pdf] for more details

///| the type of regular expressions
/// 
/// æ­£åˆ™è¡¨è¾¾å¼çš„ç±»åž‹
pub(all) enum Regex {
  Empty // ç©ºçš„æ­£åˆ™è¡¨è¾¾å¼ç±»åž‹, é€šå¸¸ç”¨äºŽè¡¨ç¤ºæ²¡æœ‰åŒ¹é…çš„æƒ…å†µ
  Impossible // æ— æ³•å®žçŽ°æˆ–å®Œæˆ
  Sym(Symbol) // ç‰¹å®šç±»åž‹
  Concat(Regex, Regex) // å°†ä¸¤ä¸ªæ­£åˆ™è¡¨è¾¾å¼è¿žæŽ¥èµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªæ–°çš„æ­£åˆ™è¡¨è¾¾å¼
  Alternative(Regex, Regex) // äºŒé€‰ä¸€
  Star(Regex)
  // technically [Plus(r)] is just [Concat(r, Star(r))], but that would duplicate [r]
  // ä»ŽæŠ€æœ¯ä¸Šè®²ï¼Œ[Plus(r)] å®žé™…ä¸Šå°±æ˜¯ [Concat(r, Star(r))]ï¼Œä½†è¿™ä¼šé‡å¤ [r]
  Plus(Regex)
}

///|
pub(all) enum Symbol {
  Any
  Chr(Char)
} derive(Eq)

///| a compiled representation of regular expression.
/// 
/// æ­£åˆ™è¡¨è¾¾å¼çš„ç¼–è¯‘è¡¨ç¤º
/// 
/// Allows efficient matching.
/// 
/// å…è®¸é«˜æ•ˆåŒ¹é… 
pub struct CompiledRegex(State)


///| A state machine, the compilation target regular expressions.
/// Represented as a graph
/// 
/// ä¸€ä¸ªçŠ¶æ€æœºï¼Œç¼–è¯‘çš„ç›®æ ‡ä¸ºæ­£åˆ™è¡¨è¾¾å¼ã€‚è¡¨ç¤ºä¸ºä¸€ä¸ªå›¾ã€‚
pub struct State {
  accepting : Bool
  mut transitions : List[(Symbol, State)]
}

enum List[X] {
  Nil
  Cons(X, List[X])
} derive(Eq)

///|
// impl Eq for State with equal(s1 : State, s2 : State) -> Bool {
//   physical_equal(s1, s2)
// }

///|
pub impl Mul for Regex with mul(self : Regex, r : Regex) -> Regex {
  match (self, r) {
    (Empty, r) | (r, Empty) => r
    (Impossible, _) | (_, Impossible) => Impossible
    (Concat(r1, r2), r) => Concat(r1, Concat(r2, r))
    (r1, r2) => Concat(r1, r2)
  }
}

///|
pub impl Add for Regex with add(self : Regex, r : Regex) -> Regex {
  match (self, r) {
    (Impossible, r) | (r, Impossible) => r
    (Alternative(r1, r2), r) => Alternative(r1, Alternative(r2, r))
    (r1, r2) =>
      // This is slow, but necessary for termination è¿™å¾ˆæ…¢ï¼Œä½†å¯¹äºŽç»ˆæ­¢æ˜¯å¿…è¦çš„
      if r1 == r2 {
        r1
      } else {
        Alternative(r1, r2)
      }
  }
}

///|
pub impl Eq for Regex with equal(self : Regex, r : Regex) -> Bool {
  match (self, r) {
    (Empty, Empty) => true
    (Impossible, Impossible) => true
    (Sym(s1), Sym(s2)) => s1 == s2
    (Concat(r11, r12), Concat(r21, r22)) => r11 == r12 && r21 == r22
    (Star(r1), Star(r2)) => r1 == r2
    _ => false
  }
}

///|
pub fn chr(c : Char) -> Regex {
  Sym(Chr(c))
}

///|
pub fn star(r : Regex) -> Regex {
  Star(r)
}

///| compile a regular expression to a state machine 
/// 
/// ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼åˆ°çŠ¶æ€æœº
pub fn Regex::compile(self : Regex) -> CompiledRegex {
  let mut current_states : List[(Regex, State)] = Nil
  fn go(r : Regex) {
    match List::assoc(current_states, r) {
      Some(state) => state
      None => {
        let state = { accepting: r.nullable(), transitions: Nil }
        current_states = Cons((r, state), current_states)
        // for every possible head character, create a transition å¯¹äºŽæ¯ä¸ªå¯èƒ½çš„å¤´éƒ¨å­—ç¬¦ï¼Œåˆ›å»ºä¸€ä¸ªè½¬æ¢
        r
        .head_symbols()
        .iter(fn(s) {
          state.transitions = Cons((s, go(r.derivative(s))), state.transitions)
        })
        state
      }
    }
  }

  CompiledRegex(go(self))
}

///| `r.derivative(c)` returns a regular expression `r'`,
/// such that `r` matches `c ++ s` if and only if `r` matches `s`
/// 
/// `r.derivative(c)` è¿”å›žä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ `r'`ï¼Œ
/// ä½¿å¾— `r` åŒ¹é… `c ++ s` å½“ä¸”ä»…å½“ `r'` åŒ¹é… `s`
fn Regex::derivative(self : Regex, c : Symbol) -> Regex{
  match self {
    Empty => impossible()
    Impossible => impossible()
    Sym(c2) => 
      match (c, c2) {
        (Chr(c1), Chr(c2)) => if c1 == c2 { empty() } else { impossible() }
        (Any, Chr(_)) => impossible()
        (_, Any) => empty()
      }
    Concat(r1, r2) => {
      let dr1 = r1.derivative(c)
      if r1.nullable() {
        dr1 * r2 + r2.derivative(c)
      } else {
        dr1 * r2
      }
    }
    Alternative(r1, r2) => r1.derivative(c) + r2.derivative(c)
    Star(r) => r.derivative(c) * star(r)
    Plus(r) => r.derivative(c) * star(r)
  }
}

// smart constructors.
// Make the shape of regex more normalized, for easier equality test
// æ™ºèƒ½æž„é€ å™¨ã€‚
// ä½¿æ­£åˆ™è¡¨è¾¾å¼çš„å½¢çŠ¶æ›´åŠ è§„èŒƒåŒ–ï¼Œä»¥ä¾¿æ›´å®¹æ˜“åœ°è¿›è¡Œç­‰å€¼æµ‹è¯•
///|
fn impossible() -> Regex {
  Impossible  
}

///| 
fn empty() -> Regex{
  Empty
}

///|
fn[X] List::iter(self : List[X], f : (X) -> Unit) -> Unit {
  match self {
    Nil => ()
    Cons(hd, tl) => {
      f(hd)
      tl.iter(f)
    } 
  }
}

///| calculate the list of characters that may appear in the front of a regular expression
/// 
/// è®¡ç®—æ­£åˆ™è¡¨è¾¾å¼å‰é¢å¯èƒ½å‡ºçŽ°çš„å­—ç¬¦åˆ—è¡¨
fn Regex::head_symbols(self : Regex) -> List[Symbol] {
  fn go(acc: List[Symbol], r : Regex) {
    match r {
      Empty | Impossible => acc
      Sym(s) => if acc.contains(s) { acc } else { Cons(s, acc) }
      Concat(r1, r2) => {
        let acc = go(acc, r1)
        if r1.nullable() {
          go(acc, r2)
        } else {
          acc
        }
      }
      Alternative(r1, r2) => go(go(acc, r1), r2)
      Star(r) | Plus(r) => go(acc, r)
    }
  }

  go(Nil, self)
}

///|
fn[X : Eq] List::contains(self : List[X], elem : X) -> Bool {
  match self {
    Nil => false
    Cons(hd, tl) => hd == elem || tl.contains(elem) //ðŸ‘
  }
}

// some list operations
///|
fn[K : Eq, V] List::assoc(lst : List[(K, V)], key : K) -> V? {
  match lst {
    Nil => None
    Cons((key1, value), rest) =>
      if key1 == key {
        Some(value)
      } else {
        List::assoc(rest, key)
      }
  }
}

///| check if a regular expression accepts the empty string
/// 
/// æ£€æŸ¥æ­£åˆ™è¡¨è¾¾å¼æ˜¯å¦æŽ¥å—ç©ºå­—ç¬¦ä¸²
fn Regex::nullable(self : Regex) -> Bool {
  match self {
    Empty => true
    Impossible => false
    Sym(_) => false
    Concat(r1, r2) => r1.nullable() && r2.nullable()
    Alternative(r1, r2) => r1.nullable() || r2.nullable()
    Star(_) => true
    Plus(r) => r.nullable()
  }
}

///| Decides if a string matches a regular expression.
/// 
/// This is a simple but slow implementation based on derivative, similar to an interpreter
/// 
/// åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼ã€‚
/// 
/// è¿™æ˜¯ä¸€ç§åŸºäºŽå¯¼æ•°çš„ç®€å•ä½†ç¼“æ…¢çš„å®žçŽ°ï¼Œç±»ä¼¼äºŽè§£é‡Šå™¨
pub fn Regex::matches(self : Regex, s : String) -> Bool {
  let mut r = self
  let mut i = 0
  while i < s.length() {
    match r {
      Impossible => return false
      _ => ()
    }
    r = match r.derivative(Chr(s.get_char(i).unwrap())) {
      Impossible => r.derivative(Any)
      rd => rd
    }
    i = i + 1
  }
  return r.nullable()
}

///|
pub fn CompiledRegex::matches(self : CompiledRegex, s : String) -> Bool {
  self.inner().accepts(s, 0)
}

///| checks whether `self` accepts the sub string of `s` starting from `offset`
/// 
/// æ£€æŸ¥`self`æ˜¯å¦æŽ¥å—ä»Ž`offset`å¼€å§‹çš„`s`çš„å­å­—ç¬¦ä¸²
fn State::accepts(self : State, s : String, offset : Int) -> Bool {
  if offset >= s.length() {
    return self.accepting
  }
  match List::assoc(self.transitions, Chr(s.get_char(offset).unwrap())) {
    Some(next_state) => next_state.accepts(s, offset + 1)
    None =>
      match List::assoc(self.transitions, Any) {
        Some(next_state) => next_state.accepts(s, offset + 1)
        None => false
      }
  }
}
