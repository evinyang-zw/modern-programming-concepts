# [阅读月兔语法教程 (doing)](https://docs.moonbitlang.com/zh-cn/latest/language/index.html)

## 基础

### 内置数据结构
#### **Ref**
- `Ref[T]`是一个包含类型T的值val的可变引用
- 可以使用`{ val : x }`构造它，并可以使用ref.val访问它
```mbt
let a : Ref[Int] = { val: 100 }
test {
  a.val = 200
  assert_eq(a.val, 200)
  a.val += 1
  assert_eq(a.val, 201)
}
```
### 控制结构

### 模式匹配
#### **数组模式**

## 使用包管理项目

### 访问控制
#### **类型**
- `pub(all)`
    - `Fully public types, declared with pub(all).`
    - 完全公开类型，使用`pub(all)`声明
    - 外部世界可以自由构造、修改和读取这些类型的值
## 错误代码索引
### E4120
- 应用可能会引发错误，但没有处理。请在应用中添加一个中缀运算符`!`或`?` 
- 运算符`!` —— 用于重新引发错误
- 运算符`?` —— 用于将错误物化为`Result[T, E]`类型
#### 错误示例
```mbt
fn may_raise_error(input : Int) -> Unit! {
  if input == 42 {
    return
  }
  fail!("failed")
}

fn main {
  may_raise_error(42)
  // Error: The application might raise errors of type Error, but it's not handled.
  // Try adding a infix operator `!` or `?` to the application, so that it looks like `...!(...)` or `...?(...)`.
}
```
#### 建议
- 可以重新引发错误：
```mbt
fn main {
  try {
    may_raise_error!(42)
  } catch {
    error => println("Error: \{error}")
  }
}
```
- 或者将错误物化为`Result[T, E]`类型：
```mbt
fn main {
  let result = may_raise_error?(42)
  println("Result: \{result}")
}
```
